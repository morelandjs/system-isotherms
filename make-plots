#!/usr/bin/env python3

import argparse
from collections import OrderedDict
from itertools import islice
import logging
from pathlib import Path
import subprocess

import h5py
import matplotlib.pyplot as plt
import numpy as np
from scipy.ndimage.measurements import center_of_mass

# new tableau colors
# https://www.tableau.com/about/blog/2016/7/colors-upgrade-tableau-10-56782
colors = OrderedDict([
    ('blue', '#4e79a7'),
    ('orange', '#f28e2b'),
    ('green', '#59a14f'),
    ('red', '#e15759'),
    ('cyan', '#76b7b2'),
    ('purple', '#b07aa1'),
    ('brown', '#9c755f'),
    ('yellow', '#edc948'),
    ('pink', '#ff9da7'),
    ('gray', '#bab0ac')
])

offblack = '.15'

fontsize = dict(
    large=11,
    normal=10,
    small=9,
    tiny=8,
)

plt.rcdefaults()
plt.rcParams.update({
    'font.family': 'sans-serif',
    'font.sans-serif': ['Lato'],
    'mathtext.fontset': 'custom',
    'mathtext.default': 'it',
    'mathtext.rm': 'sans',
    'mathtext.it': 'sans:italic:medium',
    'mathtext.cal': 'sans',
    'font.size': fontsize['normal'],
    'legend.fontsize': fontsize['normal'],
    'axes.labelsize': fontsize['normal'],
    'axes.titlesize': fontsize['large'],
    'xtick.labelsize': fontsize['small'],
    'ytick.labelsize': fontsize['small'],
    'font.weight': 400,
    'axes.labelweight': 400,
    'axes.titleweight': 400,
    'axes.prop_cycle': plt.cycler('color', list(colors.values())),
    'lines.linewidth': .8,
    'lines.markersize': 3,
    'lines.markeredgewidth': 0,
    'patch.linewidth': .8,
    'axes.linewidth': .6,
    'xtick.major.width': .6,
    'ytick.major.width': .6,
    'xtick.minor.width': .4,
    'ytick.minor.width': .4,
    'xtick.major.size': 3.,
    'ytick.major.size': 3.,
    'xtick.minor.size': 2.,
    'ytick.minor.size': 2.,
    'xtick.major.pad': 3.5,
    'ytick.major.pad': 3.5,
    'axes.labelpad': 4.,
    'axes.formatter.limits': (-5, 5),
    'axes.spines.top': False,
    'axes.spines.right': False,
    'text.color': offblack,
    'axes.edgecolor': offblack,
    'axes.labelcolor': offblack,
    'xtick.color': offblack,
    'ytick.color': offblack,
    'legend.frameon': False,
    'image.cmap': 'Blues',
    'image.interpolation': 'none',
})

plotdir = Path('plots')
plotdir.mkdir(exist_ok=True)

plot_functions = {}

grid_max = {'p p': 4, 'p Pb': 6, 'Pb Pb': 8}
grid_step = 0.082118


def plot(f):
    """
    Plot function decorator.  Calls the function, does several generic tasks,
    and saves the figure as the function name.

    """
    def wrapper(*args, **kwargs):
        logging.info('generating plot: %s', f.__name__)
        f(*args, **kwargs)

        fig = plt.gcf()

        plotfile = plotdir / '{}.pdf'.format(f.__name__)
        fig.savefig(str(plotfile))
        logging.info('wrote %s', plotfile)
        plt.close(fig)

    plot_functions[f.__name__] = wrapper

    return wrapper


def figsize(relwidth=1, aspect=.618, refwidth=6):
    """
    Return figure dimensions from a relative width (to a reference width) and
    aspect ratio (default: 1/golden ratio).

    """
    width = relwidth * refwidth
    return width, width*aspect


def set_tight(fig=None, **kwargs):
    """
    Set tight_layout with a better default pad.

    """
    if fig is None:
        fig = plt.gcf()

    kwargs.setdefault('pad', .1)
    fig.set_tight_layout(kwargs)


def cmap_to_alpha(cmap=plt.cm.inferno, fraction=.2):
    """
    Fade the bottom of a colormap to white.

    Currently only works with ListedColormap objects, of which the new cmaps
    (inferno, magma, plasma, viridis) are examples.

    """
    try:
        colors = cmap.colors.copy()
        n = int(fraction*len(colors))

        for i, rgb in enumerate(colors[:n]):
            colors[i] = rgb + [i/n]

        return type(cmap)(colors, cmap.name + '_mod')
    except AttributeError:
        cmin = 25 if cmap == plt.cm.Oranges_r else 0
        colors = [list(cmap(n/256)) for n in range(cmin, 200)]
        n = int(fraction*len(colors))

        for i, rgb in enumerate(colors[:n]):
            rgb[-1] = i/n
            colors[i] = rgb

        return ListedColormap(colors, cmap.name + '_mod')


def run_cmd(*args):
    """
    Run and log a subprocess.
    """
    cmd = ' '.join(args)
    logging.info('running command: %s', cmd)

    try:
        proc = subprocess.run(
            cmd.split(), check=True,
            stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
            universal_newlines=True
        )
    except subprocess.CalledProcessError as e:
        logging.error(
            'command failed with status %d:\n%s',
            e.returncode, e.output.strip('\n')
        )
        raise
    else:
        logging.debug(
            'command completed successfully:\n%s',
            proc.stdout.strip('\n')
        )
        return proc


def trento_gen(system, mlo=0, mhi=float('inf'), return_array=False):
    """
    Generates minimum bias trento events satisfying mlo < mult < mhi.

    Yields initial condition event grids if array is True, otherwise
    the event multiplicities.

    """
    cachefile = Path('cache', 'events.hdf')
    cachefile.parent.mkdir(parents=True, exist_ok=True)
    n = 0

    while True:
        logging.info('running new batch of trento events')

        if cachefile.exists():
            cachefile.unlink()

        proc = run_cmd(
            'trento {}'.format(system),
            '--number-events {}'.format(10**4),
            '--normalization {}'.format(20.448),
            '--cross-section {}'.format(7.0),
            '--reduced-thickness {}'.format(0.010533),
            '--fluctuation {}'.format(0.20643),
            '--nucleon-width {}'.format(0.88919),
            '--parton-number {}'.format(6),
            '--parton-width {}'.format(0.41059),
            '--nucleon-min-dist {}'.format(0.83528),
            '--grid-max {}'.format(grid_max[system]),
            '--grid-step {}'.format(grid_step if return_array else 0.2),
            '--output {}'.format(cachefile) if return_array else ''
        )

        if return_array is True:
            with h5py.File(cachefile, 'r') as f:
                for ev in f.values():
                    mult = ev.attrs['mult']
                    renorm = (3 if system == 'p p' else 1)
                    if mlo < renorm*mult < mhi:
                        ev = np.array(ev)
                        mid = 0.5*set(ev.shape).pop()
                        di, dj = [int(index - mid) for index in center_of_mass(ev)]

                        for shift, axis in [(-di, 0), (-dj, 1)]:
                            ev = np.roll(ev, shift, axis=axis)

                        yield renorm*ev
        else:
            for line in proc.stdout.splitlines():
                yield float(line.split()[3])


@plot
def mult_dist():
    """
    Histogram p-p, p-Pb, and Pb-Pb integrated reduced thickness function,
    which is roughly proportional to the final charged particle multiplicity.

    """
    plt.figure(figsize=figsize(.6))
    bins = np.linspace(0, 300, 100)
    const_dndy = 100

    for system in ['p p', 'p Pb', 'Pb Pb']:

        cachefile = Path('cache', '{}-mult.npy'.format(''.join(system.split())))
        cachefile.parent.mkdir(parents=True, exist_ok=True)

        if cachefile.exists():
            dndy = np.load(cachefile)
        else:
            dndy = np.fromiter(islice(trento_gen(system), 10**5), float)
            np.save(cachefile, dndy)

        cent = '{0:.3f}%'.format(100*sum(dndy > const_dndy)/dndy.size)
        label = '{}, {}'.format('-'.join(system.split()), cent)
        plt.hist(dndy, bins=bins, histtype='step', label=label)

    plt.axvline(100, dashes=(4, 2), color=offblack)

    plt.xlabel('$dN_g/dy$')
    plt.xlim(0, 300)
    plt.ylabel('Events')
    plt.ylim(1, 10**5)
    plt.yscale('log')

    plt.title('MAP parameters $\sqrt{s_{NN}}=5.02$ TeV')
    leg = plt.legend(
        title='system, centrality',
        fontsize=fontsize['small'],
        borderaxespad=0
    )
    plt.setp(leg.get_title(), fontsize=fontsize['small'])
    set_tight()


@plot
def single_shot_events():
    """
    Generate a sample of minimum bias events satisfying mlo < mult < mhi,
    and average the event profiles in their center of mass frame.

    Plot the resulting 2D image profiles.

    """
    fig, axes = plt.subplots(ncols=3, sharey=True, figsize=figsize(1, .4))
    systems = ['p p', 'p Pb', 'Pb Pb']

    for ax, system in zip(axes, systems):
        cachefile = Path('cache', '{}-avg-event.npy'.format(''.join(system.split())))
        cachefile.parent.mkdir(parents=True, exist_ok=True)

        if cachefile.exists():
            average_event = np.load(cachefile)
        else:
            events = islice(
                trento_gen(system, mlo=95, mhi=105, return_array=True), 1000
            )
            average_event = np.mean(list(events), axis=0)
            np.save(cachefile, average_event)

        dndy = average_event.sum()*grid_step**2

        xymax = grid_max[system]
        ax.imshow(average_event, extent=(-xymax, xymax, -xymax, xymax),
                  cmap=cmap_to_alpha())

        ax.set_xlabel('$x$ [fm]')
        if ax.is_first_col():
            ax.set_ylabel('$y$ [fm]')

        ax.set_title('{}, 5.02 TeV'.format('-'.join(system.split())))
        ax.annotate(r'$\langle dN_g/dy \rangle={0:.2f}$'.format(dndy), xy=(.9, .9),
                    xycoords='axes fraction', ha='right')

        ax.set_xlim(-5, 5)
        ax.set_ylim(-5, 5)
        ax.set_xticks([-4, -2, 0, 2, 4])
        ax.set_yticks([-4, -2, 0, 2, 4])

        ax.set_aspect('equal')

    set_tight(fig)


def main():
    logging.basicConfig(level=logging.INFO)

    parser = argparse.ArgumentParser()
    parser.add_argument('plots', nargs='*')
    args = parser.parse_args()

    if args.plots:
        for i in args.plots:
            if i.endswith('.pdf'):
                i = i[:-4]
            if i in plot_functions:
                plot_functions[i]()
            else:
                print('unknown plot:', i)
    else:
        for f in plot_functions.values():
            f()


if __name__ == "__main__":
    main()
